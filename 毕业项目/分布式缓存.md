###### **分布式缓存总结**

缓存：
redis
使用 redis 的好处：
    (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。速度快的原因：①绝大部分请求是纯粹的内存操作；②采用单进程单线程，避免了不必要的上下文切换和竞争条件；③非阻塞IO（多路复用io）。
    (2) 支持丰富数据类型，支持string，list，hash，set，sorted set。
    (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行。
    (4) 丰富的特性：可用于缓存，消息队列，按key设置过期时间，过期后将会自动删除。

支持三种高级数据结构
    - Bitmaps bitmaps不是一个真实的数据结构。 而是String类型上的一组面向bit操作的集合。 由于
      strings是二进制安全的blob， 并且它们的最大长度是512m， 所以bitmaps能最大设置
      2^32个不同的bit。  
    - Hyperloglog  在redis的实现中， 您使用标准错误小于1％的估计度量结束。 这个算法的神奇在于不再
      需要与需要统计的项相对应的内存， 取而代之， 使用的内存一直恒定不变。 最坏的情况
      下只需要12k， 就可以计算接近2^64个不同元素的基数。  
    - GEO Redis的GEO特性在 Redis3.2版本中推出， 这个功能可以将用户给定的地理位置（经
      度和纬度） 信息储存起来， 并对这些信息进行操作。
  
redis 可以能够快速执行的原因：
  
  　　(1) 绝大部分请求是纯粹的内存操作（非常快速）
  　　(2) 采用单线程,避免了不必要的上下文切换和竞争条件
  　　(3) 非阻塞IO - IO多路复用（IO 多路复用是什么意思？）
  
  IO多路复用中有三种方式：select,poll,epoll。需要注意的是，select,poll是线程不安全的，epoll是线程安全的
  
  redis内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。
 
分布式redis：
  1、主从复制
      将一台redis服务器的数据，复制到其他的redis服务器。前者称为主节点，后者为从节点，数据的复制都是单向，只能从主节点到从节点。Master以写为主，Slave以读为主。主从复制可以数据冗余、故障恢复、负载均衡、高可用的基础。
  2、哨兵模式
    通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。
    哨兵集群是基于pub/sub机制组建的。哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。哨兵向主库发送 INFO 命令，获取从库列表。哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。

常见问题
缓存穿透
    原因
        大量并发查询不存在的KEY， 导致都直接将压力透传到数据库  
    解决办法
        - 缓存空值的KEY， 这样第一次不存在也会被加载会记录， 下次拿到有这个KEY。  
        - 完全以缓存为准， 使用 延迟异步加载 的策略， 这样就不会触发更新  
        - Bloom过滤或RoaringBitmap 判断KEY是否存在  

缓存击穿
    原因
        某个KEY失效的时候， 正好有大量并发请求访问这个KEY  
    解决办法
        - KEY的更新操作添加全局互斥锁  
        - 完全以缓存为准， 使用 延迟异步加载 的策略， 这样就不会触  

缓存雪崩
    原因
        当某一时刻发生大规模的缓存失效的情况， 会有大量的请求进来直接打到数据库， 导致数
    据库压力过大升值宕机  
    解决办法
        - 更新策略在时间上做到比较均匀  
        - 使用的热数据尽量分散到不同的机器上  
        - 多台机器做主从复制或者多副本， 实现高可用  
        - 实现熔断限流机制， 对系统进行负载能力控制  

使用建议
    - 线上禁止部分命令，包括：KEYS、FLUSHALL、FLUSHDB；具体做法是管理员用rename-command命令在配置文件对这些命令进行重命名，让客户端无法使用这些命令
    - 使用业务名做key的前缀，并使用缩写形式
    - 控制key的长度
    - 使用高效序列化方法和压缩方法
    - 使用整数对象共享池
    - 不同的业务数据保存到不同实例
    - 数据保存时设置过期时间
    - 慎用MONITOR命令
    - 慎用全量操作命令
    - 控制String类型操作的大小不超过10KB
    - 控制集合类型的元素不超过10000个
    - 使用Redis保存热数据上做到比较均匀  
    - 使用的热数据尽量分散到不同的机器上  
    - 多台机器做主从复制或者多副本， 实现高可用  
    - 实现熔断限流机制， 对系统进行负载能力控制  
